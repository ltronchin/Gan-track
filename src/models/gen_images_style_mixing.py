"""
Two sets of images were generated from their respective latent codes (sources A and B); the rest of the images were generated by copying
a specified subset of styles from source B and taking the rest from source A. Copying the styles corresponding to coarse spatial resolutions
(first layer in the network) brings to strong transformation in the images (like shapes), while preserving some finer information from source A
(information inside the lesion).
If we instead copy the style of middle resolution from B, we keep the shape of the lung while having some finer changes inside the lung.
Finally, copying the fine style from B brings mainly the color  scheme and microstructure.
"""


#  Libraries
print('Import the library')
import sys
print('Python %s on %s' % (sys.version, sys.platform))
sys.path.extend(["./", "./src/models/stylegan3/", "./src/models/stylegan3/dnnlib", "./src/models/stylegan3/torch_utils"])

import os
import argparse
import yaml
import time
import pickle
import re
from typing import List

import numpy as np
import PIL.Image

import torch

from src.utils import util_general

def setup_snapshot_image_grid(training_set, random_seed=0):
    rnd = np.random.RandomState(random_seed)
    gw = np.clip(7680 // training_set.image_shape[2], 7, 32)
    gh = np.clip(4320 // training_set.image_shape[1], 4, 32)

    # No labels => show random subset of training samples.
    if not training_set.has_labels:
        all_indices = list(range(len(training_set)))
        rnd.shuffle(all_indices)
        grid_indices = [all_indices[i % len(all_indices)] for i in range(gw * gh)]

    else:
        # Group training samples by label.
        label_groups = dict() # label => [idx, ...]
        for idx in range(len(training_set)):
            label = tuple(training_set.get_details(idx).raw_label.flat[::-1])
            if label not in label_groups:
                label_groups[label] = []
            label_groups[label].append(idx)

        # Reorder.
        label_order = sorted(label_groups.keys())
        for label in label_order:
            rnd.shuffle(label_groups[label])

        # Organize into grid.
        grid_indices = []
        for y in range(gh):
            label = label_order[y % len(label_order)]
            indices = label_groups[label]
            grid_indices += [indices[x % len(indices)] for x in range(gw)]
            label_groups[label] = [indices[(i + gw) % len(indices)] for i in range(len(indices))]

    # Load data.
    images, labels = zip(*[training_set[i] for i in grid_indices])
    return (gw, gh), np.stack(images), np.stack(labels)

#----------------------------------------------------------------------------

def save_image_grid(img, fname, drange, grid_size):
    lo, hi = drange
    img = np.asarray(img, dtype=np.float32)
    img = (img - lo) * (255 / (hi - lo))
    img = np.rint(img).clip(0, 255).astype(np.uint8) # np.rint Round elements of the array to the nearest integer.

    gw, gh = grid_size
    _N, C, H, W = img.shape
    img = img.reshape([gh, gw, C, H, W])
    img = img.transpose(0, 3, 1, 4, 2)
    img = img.reshape([gh * H, gw * W, C])

    assert C in [1, 3]
    if C == 1:
        PIL.Image.fromarray(img[:, :, 0], 'L').save(fname)
    if C == 3:
        PIL.Image.fromarray(img, 'RGB').save(fname)

#----------------------------------------------------------------------------

def save_image(img, fname, drange=None):
    if drange is None:
        lo = img.min().item()
        hi = img.max().item()
    else:
        lo, hi = drange
    img = np.asarray(img, dtype=np.float32)
    img = (img - lo) * (255 / (hi - lo))
    img = np.rint(img).clip(0, 255).astype(np.uint8) # np.rint Round elements of the array to the nearest integer.

    _N, C, H, W = img.shape
    assert C in [1, 3]
    if C == 1:
        PIL.Image.fromarray(img[0][0], 'L').save(fname)
    if C == 3:
        PIL.Image.fromarray(img, 'RGB').save(fname)

#----------------------------------------------------------------------------

def num_range(s: str) -> List[int]:
    '''Accept either a comma separated list of numbers 'a,b,c' or a range 'a-c' and return as a list of ints.'''

    range_re = re.compile(r'^(\d+)-(\d+)$')
    m = range_re.match(s)
    if m:
        return list(range(int(m.group(1)), int(m.group(2))+1))
    vals = s.split(',')
    return [int(x) for x in vals]

# Argument function
def get_args():
    parser = argparse.ArgumentParser(description="Configuration File")
    parser.add_argument("-f", "--cfg_file", help="Path of Configuration File",  required=True)
    parser.add_argument("-i", "--id_exp", help="Id of experiment to load models and datas", type=int, default=1)
    parser.add_argument("-g", "--gpu", help="CUDA device", type=str, default="cuda:0")
    parser.add_argument("--dataset", help="Dataset to upload", type=str,  required=True)

    parser.add_argument("--path_gan", help="Path to the pretrained GAN", type=str, required=True)

    parser.add_argument("--mode", default='client')
    parser.add_argument("--port", default=53667)
    return parser.parse_args()

# Configuration file
print("Upload configuration file")
debug = 'develop' # 'develop'
debug = input(f"Enter '{debug}' to run a debug session press enter otherwise")
if debug == 'develop':
    with open('./configs/claro_stylegan2-ada.yaml') as file:
        cfg = yaml.load(file, Loader=yaml.FullLoader)
    id_exp = cfg['id_exp']
    worker = cfg['device']['worker']
    dataset_name = cfg['data']['dataset']

    gan_dir = cfg['prerequisites']['model_gan']
else:
    args = get_args()
    with open(args.cfg_file) as file:
        cfg = yaml.load(file, Loader=yaml.FullLoader)

    id_exp = args.id_exp
    worker = args.gpu
    dataset_name = args.dataset

    gan_dir = args.path_gan

# Submit run:
print("Submit run")
run_module = os.path.basename(__file__)
# Get new id_exp
if id_exp is None:
    run_id = util_general.get_next_run_id_local(os.path.join('log_run', dataset_name), run_module) # GET run id
else:
    run_id = id_exp
# Create log dir
run_name = "{0:05d}--{1}".format(run_id, run_module)
log_dir = os.path.join('log_run', dataset_name, run_name)
util_general.create_dir(log_dir)
# Save the configuration file
with open(os.path.join(log_dir, 'configuration.yaml'), 'w') as f:
    yaml.dump(cfg, f, default_flow_style=False)
# Initialize Logger
logger = util_general.Logger(file_name=os.path.join(log_dir, 'log.txt'), file_mode="w", should_flush=True)
# Copy the code in log_dir
files = util_general.list_dir_recursively_with_ignore('src', ignores=['.DS_Store', 'models'], add_base_to_relative=True)
files = [(f[0], os.path.join(log_dir, f[1])) for f in files]
util_general.copy_files_and_create_dirs(files)

# Welcome
from datetime import datetime
now = datetime.now()
date_time = now.strftime("%d/%m/%Y, %H:%M:%S")
print("Hello!",date_time)

# Seed everything
print("Seed all")
util_general.seed_all(cfg['seed'])

# Parameters
print("Parameters")
image_size = cfg['data']['image_size']
channel = cfg['data']['channel']
iid_class = cfg['data']['iid_classes']
ood_class  = cfg['data']['ood_classes']
print(f"gan pretrained dir: {gan_dir}")

# Useful print
print(f"id_exp: {id_exp}")
print(f"iid classes:{iid_class}")
print(f"ood classes:{ood_class}")

# Register and history
print("Initialize history")
overall_time = util_general.nested_dict()
overall_history = {}
start = time.time()

# Device
print("Select device")
device = torch.device(worker if torch.cuda.is_available() else "cpu")
num_workers = 0 if device.type == "cpu" else cfg['device']['gpu_num_workers']
print(f'device: {device}')

# Files and Directories
print('Create file and directory')
data_dir = os.path.join(cfg['data']['data_dir'], dataset_name)
interim_dir = os.path.join(cfg['data']['interim_dir'], dataset_name, run_name)
util_general.create_dir(interim_dir)
model_dir = os.path.join(cfg['data']['model_dir'], dataset_name, run_name)
util_general.create_dir(model_dir)
reports_dir = os.path.join(cfg['data']['reports_dir'], dataset_name, run_name)
util_general.create_dir(reports_dir)
general_reports_dir = os.path.join(reports_dir, "general")
util_general.create_dir(general_reports_dir)

print('Loading networks from "%s"...' % gan_dir)
with open(gan_dir, 'rb') as f:
    G = pickle.load(f)['G_ema'].to(device)  # torch.nn.Module

class_label = None
truncation_psi=1
noise_mode='const'
row_seeds = num_range('85,100,75,458,1500')
col_seeds = num_range('55,821,1789,293')
col_styles = num_range('10-13') # 'Style layer range'

print('Generating W vectors...')
all_seeds = list(set(row_seeds + col_seeds))
all_z = np.stack([np.random.RandomState(seed).randn(G.z_dim) for seed in all_seeds])
all_w = G.mapping(z=torch.from_numpy(all_z).to(device), c=class_label)

w_avg = G.mapping.w_avg
all_w = w_avg + (all_w - w_avg) * truncation_psi

w_dict = {seed: w for seed, w in zip(all_seeds, list(all_w))}

print('Generating images...')
all_images = torch.stack([G.synthesis(w.unsqueeze(0), noise_mode=noise_mode, force_fp32=True)[0] for w in all_w])
all_images = (all_images.permute(0, 2, 3, 1) * 127.5 + 128).clamp(0, 255).to(torch.uint8).cpu().numpy()
image_dict = {(seed, seed): image for seed, image in zip(all_seeds, list(all_images))}

print('Generating style-mixed images...')
for row_seed in row_seeds:
    for col_seed in col_seeds:
        w = w_dict[row_seed].clone() # copy in w the vector for the row image
        w[col_styles] = w_dict[col_seed][col_styles] # overlapping some w row of row image with w row of column image.
        # With col_style we control which layer of the Generator will be feed to the first or second style.
        # Note that the Generator has 14 layer, so we can combine the two style at different layer: with col_style equal to [0, 1, 3] we are feedind to G
        # the w vector of column image.
        image = G.synthesis(w[np.newaxis], noise_mode=noise_mode)
        image = (image.permute(0, 2, 3, 1) * 127.5 + 128).clamp(0, 255).to(torch.uint8)
        image_dict[(row_seed, col_seed)] = image[0].cpu().numpy()

print('Saving images...')
os.makedirs(general_reports_dir, exist_ok=True)
for (row_seed, col_seed), image in image_dict.items():
    PIL.Image.fromarray(image[:, :, 0], 'L').save(f'{general_reports_dir}/{row_seed}-{col_seed}.png')

print('Saving image grid...')
W = G.img_resolution
H = G.img_resolution
canvas = PIL.Image.new('L', (W * (len(col_seeds) + 1), H * (len(row_seeds) + 1)), 'black')
for row_idx, row_seed in enumerate([0] + row_seeds):
    for col_idx, col_seed in enumerate([0] + col_seeds):
        if row_idx == 0 and col_idx == 0:
            continue
        key = (row_seed, col_seed)
        if row_idx == 0:
            key = (col_seed, col_seed)
        if col_idx == 0:
            key = (row_seed, row_seed)
        canvas.paste(PIL.Image.fromarray(image_dict[key][:,:,0], 'L'), (W * col_idx, H * row_idx))
canvas.save(f'{general_reports_dir}/grid.png')

print("May be the force with you!")